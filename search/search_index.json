{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Harmonizing the object recognition strategies of deep neural networks with humans   Thomas Fel*, Ivan Felipe Rodriguez*, Drew Linsley*,  Thomas Serre   Carney Institute for Brain Science, Brown University, Providence, RI 02912   {thomas_fel,ivan_felipe_rodriguez,drew_linsley,thomas_serre}@brown.edu  <p> Read the official paper \u00bb Explore results   \u00b7   Github   \u00b7   Models zoo   \u00b7   Tutorials   \u00b7   Click-me paper </p>"},{"location":"#paper-summary","title":"Paper summary","text":"<p>The many successes of deep neural networks (DNNs) over the past decade have largely been driven by computational scale rather than insights from biological intelligence. Here, we explore if these trends have also carried concomitant improvements in explaining visual strategies underlying human object recognition. We do this by comparing two related but distinct properties of visual strategies in humans and DNNs: where they believe important visual features are in images and how they use those features to categorize objects. Across 85 different DNNs and three independent datasets measuring human visual strategies on ImageNet, we find a trade-off between DNN top-1 categorization accuracy and their alignment with humans. State-of-the-art DNNs are progressively becoming less aligned with humans. We rectify this growing issue by introducing the harmonization procedure: a general-purpose training routine that aligns DNN and human visual strategies while improving object classification performance.</p>"},{"location":"#aligning-the-gradients","title":"Aligning the Gradients","text":"<p>Human and DNNs rely on different features to recognize objects. In contrast, our neural harmonizer aligns DNN feature importance with humans. Gradients are smoothed from both humans and DNNs with a Gaussian kernel to improve visualization.</p>"},{"location":"#breaking-the-trade-off-between-performance-and-alignment","title":"Breaking the trade-off between performance and alignment","text":"<p>The trade-off between DNN performance and alignment with human feature importance from the ClickMe dataset. Human feature alignment is the mean Spearman correlation between human and DNN feature importance maps, normalized by the average inter-rater alignment of humans. The grey-shaded region illustrates the convex hull of the trade-off between ImageNet accuracy and human feature alignment. All the models trained with the harmonization procedure are more accurate and aligned than versions of those models trained only for classification. Arrows denote a shift in performance after training with the harmonization procedure.</p>"},{"location":"#authors","title":"Authors","text":"<p>  Thomas Fel*   Ivan Felipe Rodriguez*   Drew Linsley*   Thomas Serre  <p>  * : all authors have contributed equally.  </p> </p>"},{"location":"#citation","title":"\ud83d\uddde\ufe0f Citation","text":"<p>If you use or build on our work as part of your workflow in a scientific publication, please consider citing the official paper:</p> <pre><code>@article{fel2022aligning,\n  title={Harmonizing the object recognition strategies of deep neural networks with humans},\n  author={Fel, Thomas and Felipe, Ivan and Linsley, Drew and Serre, Thomas},\n  journal={Advances in Neural Information Processing Systems (NeurIPS)},\n  year={2022}\n}\n</code></pre> <p>Moreover, this paper relies heavily on previous work from the Lab, notably Learning What and Where to Attend where the ambitious ClickMe dataset was collected.</p> <pre><code>@article{linsley2018learning,\n  title={Learning what and where to attend},\n  author={Linsley, Drew and Shiebler, Dan and Eberhardt, Sven and Serre, Thomas},\n  journal={International Conference on Learning Representations (ICLR)},\n  year={2019}\n}\n</code></pre>"},{"location":"#tutorials","title":"Tutorials","text":"<p>Evaluate your own model (pytorch and tensorflow)</p> <p> </p> <p> </p>"},{"location":"#license","title":"\ud83d\udcdd License","text":"<p>The package is released under  MIT license.</p>"},{"location":"evaluation/","title":"Evaluation","text":"<p>In order to evaluate your own model on the benchmark, we have made available two notebooks showing how to do it from tensorflow or pytorch.</p> <p> </p> <p> </p> <p>Or, you can simply use the api directly as follows:</p> <pre><code>from harmonization.common import load_clickme_val\nfrom harmonization.evaluation import evaluate_clickme\n\nclickme_dataset = load_clickme_val(batch_size = 128)\n\nscores = evaluate_clickme(model = model, # tensorflow or pytorch model\n                          clickme_val_dataset = clickme_dataset,\n                          preprocess_inputs=preprocessing_function)\nprint(scores['alignment_score'])\n</code></pre> <p>Warning</p> <p>If you are using a Pytorch model, you need to specify a explainer function (see the pytorch notebook).</p>"},{"location":"models/","title":"Model zoo","text":"<p>In our experiments, we re-trained a set of models with the harmonization loss proposed in the paper. You can easily download the weights of each models here:</p> <ul> <li>ViT B16 Harmonized: serrelab/prj_harmonization/vit_b16_harmonized</li> <li>VGG16 Harmonized: serrelab/prj_harmonization/vgg16_harmonized</li> <li>ResNet50V2 Harmonized: serrelab/prj_harmonization/resnet50v2_harmonized</li> <li>EfficientNet B0: serrelab/prj_harmonization/efficientnet_b0</li> <li>LeViT: serrelab/prj_harmonization/levit</li> <li>ConvNeXT: serrelab/prj_harmonization/convnext</li> <li>MaxViT: serrelab/prj_harmonization/maxvit</li> </ul> <p>In order to load them easily, we have set up utilities in the github repository. For example, to load the model lives harmonized:</p> <pre><code>from harmonization.models import (load_ViT_B16, load_ResNet50,\n                                  load_VGG16, load_EfficientNetB0,\n                                  load_tiny_ConvNeXT, load_tiny_MaxViT,\n                                  load_LeViT_small,\n                                  preprocess_input)\n\nvit_harmonized = load_ViT_B16()\nvgg_harmonized = load_VGG16()\nresnet_harmonized = load_ResNet50()\nefficient_harmonized = load_EfficientNetB0()\nconvnext_harmonized = load_tiny_ConvNeXT()\nmaxvit_harmonized = load_tiny_MaxViT()\nlevit_harmonized = load_LeViT_small()\n\n# load images (in [0, 255])\n# ...\n\nimages = preprocess_input(images)\npredictions = vit_harmonized(images)\n</code></pre>"},{"location":"results/","title":"Results","text":""},{"location":"results/#harmonized-vit-vs-vit","title":"Harmonized ViT vs ViT","text":"Click-Me (Human)   Baseline model   Harmonized model"},{"location":"results/#harmonized-vgg-vs-vgg","title":"Harmonized VGG vs VGG","text":"Click-Me (Human)   Baseline model   Harmonized model"},{"location":"results/#harmonized-efficientnetb0-vs-efficientnetb0","title":"Harmonized EfficientNetB0 vs EfficientNetB0","text":"Click-Me (Human)   Baseline model   Harmonized model"},{"location":"results/#harmonized-resnet50-vs-resnet50","title":"Harmonized ResNet50 vs ResNet50","text":"Click-Me (Human)   Baseline model   Harmonized model"},{"location":"training/","title":"Training","text":"<p>In order to train your own harmonized model, we have made available a way to simply load the ClickMe training set, as well as the harmonization loss we have used in the paper.</p>"},{"location":"training/#loading-clickme-training-set","title":"Loading ClickMe training set","text":"<p>First, you will need to load the training dataset:</p> <pre><code>from harmonization.common import load_clickme_train\n\nclickme_ds = load_clickme_train(batch_size = 128)\n\nfor images, heatmaps, labels in clickme_ds:\n    print(images.shape) # (128, 224, 224, 3)\n    print(heatmaps.shape) # (128, 224, 224, 1)\n    print(labels.shape) # (128, 1000)\n</code></pre> <p>Note that, if you already have the shards locally, you can also load the dataset using the <code>load_clickme</code> function:</p> <pre><code>from harmonization.common import load_clickme\n\nclickme_ds = load_clickme_train(shards_paths = ['dataset/train_clickme_0',\n                                                'dataset/train_clickme_1'\n                                                ...\n                                               ], batch_size = 128)\n</code></pre>"},{"location":"training/#using-the-harmonization-loss","title":"Using the Harmonization loss","text":"<p>Now that we know how to load the training set, we just need the harmonization loss:</p> <pre><code>def harmonizer_loss(model, images, tokens, labels, true_heatmaps,\n                    cross_entropy = tf.keras.losses.CategoricalCrossentropy(),\n                    lambda_weights=1e-5, lambda_harmonization=1.0):\n                    ...\n</code></pre> <p>To use the loss, simply call the function with your model, the images / labels and heatmaps for ClickMe:</p> <pre><code>from harmonization.training import harmonizer_loss\n\n... # loading dataset\n\n\nfor images, heatmaps, labels in clickme_ds:\n    tokens = tf.ones(len(images)) # tokens are flags to indicate if the image have an associated heatmap\n    loss = harmonizer_loss(model, images, tokens, labels, heatmaps)\n</code></pre> <p>For example, if we decide to mix the ClickMe dataset with ImageNet, we may not have heatmaps for each images, in that case we can use the <code>tokens</code> flag parameters to designate when an heatmaps is provided (<code>1</code> means heatmaps provided).</p>"}]}